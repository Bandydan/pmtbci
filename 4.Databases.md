# Базы данных.

## Введение

`MySQL` относится к **реляционным СУБД (система управления базами данных)**, что значит, что в основе проектирования и построения данных лежат связи между ними, и именно связями между данными необходимо руководствоваться при проектировании баз данных. 

Базы данных предназначены для работы с информацией: для хранения и сохранения, поиска и редактирования данных, подчиненных какой-то структуре.

Крупнейшей единицей хранения данных является база данных - набор таблиц, связей между ними и прочих элементов - триггеров, представлений, временных таблиц и т.п.

в **СУБД** может быть сколько угодно баз данных.

Основой одной базы данных является таблица. Внешне она напоминает табличку в экселе. У таблицы в "заголовке" находятся имена полей, а каждый "ряд", называемый в теории баз данных **записью**, содержит одну запись значения для каждого поля. Если таблица Student, к примеру, содержит имена студентов(name) и их возраст(age), то говорят, что в таблице Student **поля** name и age. Каждый студент, записанный в таблицу, является одной записью, и выглядит это примерно так:

**Student**

|name |age|
|:----|:-:|
|Mark |21 |
|Jeny |22 |
|Tom  |21 |

Рассмотрим вопросы создания базы данных и таблиц поподробнее.

## Подключение к СУБД на примере mySQL

Если в системе установлена СУБД MySQL, можно запустить соответствующее консольное приложение mysql, которое позволяет выполнять все доступные операции с базами данных.

Если воспринимать параметр как ключ и его значение, то **-u `username`** представляет собо пару ключ параметра `-u` и его значение `username` Обратите внимание, что после указания ключа параметра (к примеру, `-u`) можно писать значение параметра как после пробела, так слитно с ключом параметра.

Далее следует пример вызова приложения с параметрами, указанными после ключа. Параметры означают, что вместо написанного там надо подставить ваши значения:

**mysql -u`username` -p`password` -D`database name` -h`host name`**

Подробнее:

* **mysql** - название вызываемой программы
* **-u`username`** - имя пользователя. Имя пользователя подставляется вместо {username} (В open server имя стандартного пользователя - **root**)
* **-p`password`** - пароль пользователя. В open server пользователь **root** не имеет пароля, и указывать этот параметр не надо.
* **-D`database name`** - название базы данных. Указывается, когда надо подключится к конкретной базе данных. Если такой необходимости нет, параметр не указывается.
* **-h`hostname`** - имя или адрес хоста для базы данных. В случае с open server-ом это **localhost**, который можно не указывать.

Строка для стандартного подключения в open server:

`mysql -uroot`

[Более список параметров консольного приложения mysql](http://www.mysql.ru/docs/man/mysql.html)

## Выбор базы данных, просмотр таблиц

Итак, мы в консоли `mysql`. Просмотрим список существующих баз данных.
Команда `show databases;` показывает все существующие и доступные вашему пользователю базы данных. Обратите внимание, что команды `mysql`, как и команды многих других языков, необходимо заканчивать точкой с запятой.

В случае первого запуска `mysql`, пользователь увидит только три базы данных:

```sql
mysql> show databases;

+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
+--------------------+
3 rows in set (0.00 sec)
```

Далее мы на примере встроенной базы данных разберемся, как выбирать конкретную базу данных и знакомиться с ее таблицами:

```sql
mysql> use mysql;

Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql>
```
Командой `use mysql;` пользователь говорит СУБД о том, что хочет работать с базой данных `mysql`, одноименной с самой СУБД. Далее, аналогично команде `show databases;` для демонстрации доступных баз данных, применим команду `show tables;` для демонстрации списка доступных таблиц: 

```sql
mysql> show tables;

+---------------------------+
| Tables_in_mysql           |
+---------------------------+
| columns_priv              |
| db                        |
| event                     |
| func                      |
| ..........................|
| user                      |
+---------------------------+
28 rows in set (0.01 sec)
```

Всего в этой базе доступно 28 таблиц, как видно из последней строки, но нас не интересуют эти таблицы, потому для краткости отображения оставим в уроке лишь пять.

Достаточно рискованно что-то менять в трех стандартных базах данных, это чревато переустановкой `mysql`. Для того, чтобы попробовать что-то сделать самим, создадим свою базу данных. Но перед этим необходимо разобраться с пользователями.

## Пользователи и привилегии

Проверим, под каким пользователем мы подключены к СУБД:

```sql
mysql> select user(), current_user();
+----------------+----------------+
| user()         | current_user() |
+----------------+----------------+
| root@localhost | root@localhost |
+----------------+----------------+
1 row in set (0.00 sec)
```
Итак, мы подключены как пользователь `root` на хостинге `localhost`. Встроенная в `MySQL`  функция `user()` возвращает имя текущего пользователя, `current_user()` возвращает текущее имя пользователя, под которым пользователь аутентифицировался в текущей сессии. Иногда они могут различаться, что сигнализирует о проблеме с аутентификацией.

Пользователь `root` является в системах unix и linux суперпользователем, который имеет права на все. Считается небезопасным постоянно работать под суперпользователем, потому мы создадим себе другого пользователя, который будет иметь почти те же права.

Для начала, проверим, какие пользователи и под какими хостами у нас уже есть. Для этого перейдем в базу данных mysql, если мы не в ней:

```sql
mysql> use mysql;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
```

Затем выполним простейший запрос к базе данных:

```sql
mysql> select user, host from user;
+-----------+-----------+
| user      | host      |
+-----------+-----------+
| mysql.sys | localhost |
| root      | localhost |
+-----------+-----------+
3 rows in set (0.01 sec)
```

 Итак, у нас в базе два пользователя (количество пользователей может отличаться). Создадим своего пользователя специальной командой `mysql`:
 
 ```sql
mysql> CREATE USER 'stud'@'localhost' IDENTIFIED BY 'password';
Query OK, 0 rows affected (0.02 sec)
 ```
 
Итак, у нас создался новый пользователь stud, и пароль у него password.

К сожалению, по умолчанию новый пользователь практически бесправен, он может видеть ограниченное количество баз данных, и еще меньше может в них изменить. Проверим это:

```sql
mysql> show grants for stud@localhost;
+------------------------------------------+
| Grants for stud@localhost                |
+------------------------------------------+
| GRANT USAGE ON *.* TO 'stud'@'localhost' |
+------------------------------------------+
1 row in set (0.00 sec)
```
Итак, новому пользователю открыта только привилегия `USAGE`, что, как мы увидим чуть позже, означает "Ничего нельзя". Нас это не устраивает, ведь наш текущий пользователь `root` имеет больше привилегий:

```sql
mysql> show grants;
+---------------------------------------------------------------------+
| Grants for root@localhost                                           |
+---------------------------------------------------------------------+
| GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION |
| GRANT PROXY ON ''@'' TO 'root'@'localhost' WITH GRANT OPTION        |
+---------------------------------------------------------------------+
2 rows in set (0.00 sec)
```
Вот `ALL PRIVILEGES` - это серьезно, это значит, что можно все. `WITH GRANT OPTION` означает, что пользователь может еще и менять привилегии других пользователей.

Раз наш пользователь может раздавать привилегии, воспользуемся этим:

```sql
mysql> GRANT ALL PRIVILEGES ON * . * TO 'stud'@'localhost';
Query OK, 0 rows affected (0.01 sec)
```
Команда выдает привилегии указанному пользователю на указанные таблицы (`*.*` означает, все таблицы всех баз данных).
Проверим результат:

```sql
mysql> show grants for stud@localhost;
+---------------------------------------------------+
| Grants for stud@localhost                         |
+---------------------------------------------------+
| GRANT ALL PRIVILEGES ON *.* TO 'stud'@'localhost' |
+---------------------------------------------------+
1 row in set (0.00 sec)
```

Отлично, теперь мы можем заходить под нашем пользователем и работать в полную силу не переживая (особо) о безопасности нашего подключения.

[Список всех привилегий](), которые можно выдать пользователю.

Выйдем из под `root` пользователя, зайдем под студентом и приступим к созданию новой базы данных:

```sql
mysql> \q
Bye
```
Вышли из консоли `mysql`.

```bash
$ mysql -ustud -hlocalhost -p
Enter password:

Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 24
Server version: 5.7.11 Homebrew

Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql>
``` 

Мы вошли, используя команду `mysql -ustud -hlocalhost -p`. Если просто написать `-p` не вводя сам пароль, система попросит ввести пароль ниже и не отобразит его на экране, что удобно и безопасно.

Проверим, под тем ли пользователем мы зашли и что у него за привилегии:

```sql
mysql> show grants;
+---------------------------------------------------+
| Grants for stud@localhost                         |
+---------------------------------------------------+
| GRANT ALL PRIVILEGES ON *.* TO 'stud'@'localhost' |
+---------------------------------------------------+
1 row in set (0.00 sec)
```

[Немного о создании пользователей и привелегиях.](https://www.digitalocean.com/community/tutorials/mysql-ru)

Отлично, мы готовы к созданию БД и таблиц.

 
## Создание баз данных и таблиц
  
  Создание своей базы данных - дело несложное:
  
  ```sql
  create database test;
  Query OK, 1 row affected (0.00 sec)
  ```
  База создана. Переключимся в нее и добавим к ней первую табличку, тут будет немного посложнее:
  
  ```sql
mysql> use test;
Database changed  

mysql> create table cars(
       id int(5) not null primary key auto_increment,
       brand varchar(50) not null default ''
       );
Query OK, 0 rows affected (0.01 sec)
  ```
  
  Разберем эту команду подробнее:
  
  1. В первой строке выполняется команда `create table`, за которой следует название таблицы и открывающая скобка для перечисления полей таблицы.
  2. Во второй  и третьей строках создаются поля таблицы. У такого рода команд есть название: `create_definition`. Если речь о поле таблицы (а чаще всего так и есть), указывается имя поля (**id**), затем тип поля (`int`), затем в скобках максимальное количество символов или разрядов, которые будут заняты каждой записью в этом поле.
  3. После указания размера поля следуют модификаторы.
  4. Модификатор `not null` говорит СУБД о том, что в данное поле не следует записывать значение `NULL`. Если `not null` не указано, и при создании записи про поле ничего не будет известно, СУБД по умолчанию запишет `NULL`.
  5. Модификатор `auto_increment` позволяет автоматически заполнять указанное поле, каждый раз добавляя единицу к последнему существующему в таблице в этом поле значению. В таблице может быть только одно поле с таким модификатором.
  5. Модификатор `primary key` означает, что данное поле будет использовано как первичный ключ, т.е. по этому полю можно будет однозначно понять, о какой записи идет речь.
  6. В третьей строке создается поле **brand**, типа `varchar`, до 50 символов, по умолчанию не ноль.
  7. Модификатор `default` позволяет задать для поля значение по умолчанию. В данном случае это пустая строка **''**.
  8. Затем просто закрывается скобка, открытая после `create table`, и идет стандартная для команд `mysql` точка с запятой.

Отличная справочная статья, раскрывающая и уточняющая тему создания таблиц, модификаторов, типов полей и т.п. [по ссылке](http://www.spravkaweb.ru/mysql/sql/createtable).

Посмотрим на результирующую таблицу:

```sql
mysql> desc cars;
+-------+-------------+------+-----+---------+----------------+
| Field | Type        | Null | Key | Default | Extra          |
+-------+-------------+------+-----+---------+----------------+
| id    | int(5)      | NO   | PRI | NULL    | auto_increment |
| brand | varchar(50) | NO   |     |         |                |
+-------+-------------+------+-----+---------+----------------+
2 rows in set (0.01 sec)
```

Команда `desc` (сокращение от `describe`) с именем таблицы выводит краткое описание таблицы.

Так же можно посмотреть полную команду создания существующей таблицы, такой, какой ее видит `mysql`

```sql
mysql> show create table cars;
+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table | Create Table                                                                                                                                                      |
+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| cars  | CREATE TABLE `cars` (
  `id` int(5) NOT NULL AUTO_INCREMENT,
  `brand` varchar(50) NOT NULL DEFAULT '',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 |
+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.01 sec)
```

Результат в консоли немного не так красив, поскольку осуществляются переносы строк. Как видно из результата команды `show create table`, таблицы в `mysql` по умолчанию создаются на движке `InnoDB` и с набором символов `utf8`, что не может нас не радовать. Возможные движки с их плюсами и минусами мы рассмотрим позже.

## Другие операции с таблицами и базами данных

Для изменения существующей таблицы есть команда `alter table`:

```sql
mysql> alter table cars add column year int(4) not null default 2010;
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> desc cars;
+-------+-------------+------+-----+---------+----------------+
| Field | Type        | Null | Key | Default | Extra          |
+-------+-------------+------+-----+---------+----------------+
| id    | int(5)      | NO   | PRI | NULL    | auto_increment |
| brand | varchar(50) | NO   |     |         |                |
| year  | int(4)      | NO   |     | 2010    |                |
+-------+-------------+------+-----+---------+----------------+
3 rows in set (0.00 sec)
```
Мы добавили к таблице машин колонку с годом выпуска машины, использовав команду `alter table`. Тем же путем удалим эту колонку:

```sql
mysql> alter table cars drop column year;
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> desc cars;
+-------+-------------+------+-----+---------+----------------+
| Field | Type        | Null | Key | Default | Extra          |
+-------+-------------+------+-----+---------+----------------+
| id    | int(5)      | NO   | PRI | NULL    | auto_increment |
| brand | varchar(50) | NO   |     |         |                |
+-------+-------------+------+-----+---------+----------------+
2 rows in set (0.00 sec)
```

[Команда alter table](http://www.spravkaweb.ru/mysql/sql/altertable) довольно сложна, но и многое позволяет. Команда, как и при создании таблицы, позволяет добавлять и удалять колонки, менять их самыми различными способами, добавлять на них различные индексы, вешать ключи на таблицы и удалять их и так далее.

Для удаления таблиц есть две интересные команды:

`drop table` с именем таблицы просто удаляет таблицу.
`trunc table` с именем таблицы удаляет только содержимое таблицы, не меняя ее структуры, но пересоздавая первичный ключ, так что он снова будет добавлять "с единички".

База данных удаляется командой `drop database` с именем таблицы и точкой запятой в конце. 


### Полезные cсылки

[Ознакомительная статья](http://cccp-blog.com/razrabotchiku/mysql-komandnaya-stroka)



# MySQL, Манипуляции с данными

Когда база данных создана и таблицы в ней созданы, когда все это сделано правильным пользователем с правильными правами и уровнем доступа, самое время заполнить таблицы данными. В работе с данными есть всего 4 действия: создание, получение, изменение и удаление данных. Для обозначения этих действий используется аббревиатура **CRUD: Create, Read, Update, Delete**.

Для экспериментов с данными нам понадобится таблица. К примеру, таблица слов из словаря:

```sql
mysql> DESC words;

+--------+--------------+------+-----+---------+----------------+
| Field  | Type         | Null | Key | Default | Extra          |
+--------+--------------+------+-----+---------+----------------+
| id     | int(11)      | NO   | PRI | NULL    | auto_increment |
| word   | varchar(100) | NO   |     |         |                |
| voc_id | int(11)      | NO   |     | 0       |                |
+--------+--------------+------+-----+---------+----------------+
3 rows in set (0.26 sec)
```

На всякий случай приведу команду создания этой таблицы:

```sql
CREATE TABLE `words` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `word` varchar(100) NOT NULL DEFAULT '',
  `voc_id` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
);
```

Не стоит забывать, что для просмотра структуры таблицы мы пользуемся запросами **`show create table word;`** и **`desc word;`**

## CRUD данных - Create, добавление данных (INSERT)

Для добавления данных в таблицу используется оператор **`INSERT INTO`**. Оператор **`INSERT INTO`** бывает нескольких видов, и мы рассмотрим основные:

### Simple insert

Простейший вариант вставки данных в таблицу выглядит следующим образом:

```sql
INSERT INTO words SET word = "Earth", voc_id = 1;
```

В данном примере мы вставляем запись в таблицу word, указывая конкретное значение для каждого столбца в виде пары ключ-значение (key-value pair). Ключом выступает название поля, значением - собственно информация, которую мы хотим поместить в записи в это поле.
Данный вид вставки данных применяется для добавления одной записи.

### Multiple insert

```sql
INSERT INTO words (word, voc_id) VALUES ("cat", 2), ("dog", 2), ("donkey", 2);
```
Код выше вставляет данные в последующих скобках в соответствующие столбцы, указанные в первых скобках. Таким образом, вначале необходимо перечислить столбцы (поля), в которые планируется вносить данные, а затем через запятую перечислить обернутые скобочками наборы данных для этих полей. Такой запрос позволяет добавлять несколько записей разом.

```sql
INSERT INTO words VALUES (30, "cat", 2), (31, "dog", 2), (32, "donkey", 2);

```
Данный вариант запроса  **`INSERT INTO`** используется, если вы планируете заполнять все столбцы, а не только выбранные.

### Insert from select

Возможна так же вставка данных из результата запроса:

```sql
INSERT INTO words (word) SELECT word FROM words;
```
Здесь приведен довольно простой пример, но, по сути дела, если вы построите запрос данных **`SELECT`** таким образом, чтобы количество столбцов в результате соответствовало необходимому, указанному во внешнем запросе **`INSERT`**, вы можете встроить запрос довольно серьезного уровня сложности.

## CRUD данных - Read, выборка данных (SELECT)

Запрос **`SELECT`** используется для получения данных, и никоим образом их не изменяет. Структура его довольно сложна, и мы попробуем разобрать ее постепенно и поэтапно.

Минимальный возможный запрос выглядит так:

```sql
mysql> SELECT 1;
+---+
| 1 |
+---+
| 1 |
+---+
```
Единственным обязательным ключевым словом в запросе **`select`** является слово `select` - выбрать. 

После этого слова следует писать:

- функции mysql ([примеры функций](https://www.w3schools.com/sql/sql_ref_mysql.asp))
- строки и числа
- поля таблиц, временных таблиц и представлений, которые мы собираемся выбирать
- производные от этих полей

Чаще всего **`SELECT`** используется для работы с данными из таблиц, и для этого нужно указать эти самые таблицы. Таблицы, по которым осуществляется выборка, перечисляются после ключевого слова **`FROM`**:

```sql
SELECT * FROM books;
```

Приведенный выше запрос выбирает все поля (за это отвечает звездочка) из таблицы books.

Максимально подробная схема запроса `select` выглядит так:

```sql
SELECT
    <field1>,
    <field2>,
    <field3>
    ...
FROM
    <table1>,
    <table2>,
    <joins>,
    <views>,
    <temp_table>
    ...
WHERE
    <cond>
    
ORDER BY
    <field1> ASC
    <field3> DESC
GROUP BY
    <field 1>
HAVING
    <cond with aggr function>
LIMIT
    N,M
```


Ниже приведено текстовое описание основных элементов структуры запроса **`SELECT`**, более подробное описание с примерами будет приведено позже.

1. После ключевого слова **`SELECT`** идет перечень полей таблиц, функций, вычисляемых из этих полей, констант, независимых от записей функций. Для указания всех полей исопльзуется звездочка. Этот пункт является единственным обязательным пунктом в запросе **`SELECT`**, остальные опциональны.
2. Далее, после ключевого слова **`FROM`** следует перечень таблиц, представлений и временных таблиц, откуда ведется выборка. Таблицы могут быть просто перечислены, а могут быть присоединены к другим таблицам по описанным отдельно правилам, т.е. при помощи **`JOIN`**.
3. Далее следует условие **`WHERE`**, пропускающее только те записи, которые удовлетворяют перечисленным в **`WHERE`** условиям. Все не прошедшие проверку записи отфильтровываются и не демонстрируются.
4. После фильтра **`WHERE`** может следовать группировка записей. 
5. Группировка выполняется при помощи ключевых слов **`GROUP BY`**. Суть группировки в том, что записи могут объединяться по признаку или нескольким признакам в одну запись, которая несет в себе некую общую для всех записей группы информацию или результат обработки информации по всей группе. Конструкция **`GROUP BY`** может включать в себя ключевое слово **`HAVING`**, позволяющее фильтровать результаты группировки.
6. Важно отметить, что группировка позволяет использовать аггрегатные функции как в **`HAVING`**, так и после **`SELECT`**. 
5. После группировки может иметь место сортировка записей при помощи ключевых слов **`ORDER BY`**. При группировке указывается поле или перечень полей, по которому необходимо отсортировать, также можно указать направление сортировки. По умолчанию осуществляется сортировка по возрастанию. Сортировка по убыванию делается при помощи ключевого слова **`descending`** или **`desc`**.
6. В конце запроса возможно добавление ограничений на количество записей. Слово **`LIMIT`** и цифрой после указывает, сколько записей вы хотите видет в результате. Если после слова **`LIMIT`** добавить две цифры через запятую, вы увидите второе число - количество записей после пропущенного первого числа-количества записей, т.е. **`LIMIT 20, 5`** пропустит 20 записей и покажет вам 5 следующих.


## Практика по SELECT и INSERT

### DISTINCT

```sql

mysql> select word, voc_id from words;

+--------+--------+
| word   | voc_id |
+--------+--------+
| cat    |      2 |
| dog    |      2 |
| donkey |      2 |
| cat    |      2 |
| dog    |      2 |
| donkey |      2 |
| cat    |      0 |
| dog    |      0 |
| donkey |      0 |
| cat    |      0 |
| dog    |      0 |
| donkey |      0 |
+--------+--------+
12 rows in set (0.00 sec)


mysql> select distinct word, voc_id from words;

+--------+--------+
| word   | voc_id |
+--------+--------+
| cat    |      2 |
| dog    |      2 |
| donkey |      2 |
| cat    |      0 |
| dog    |      0 |
| donkey |      0 |
+--------+--------+
6 rows in set (0.00 sec)

```


Условие **`distinct`** отбрасывает дубикаты в результате запроса, оставляя только уникальные записи.

### WHERE

Теперь выберем все слова и несколько раз отфильтруем их при помощи **`where`**:

```sql

mysql> select * from words;

+----+--------+--------+
| id | word   | voc_id |
+----+--------+--------+
|  1 | cat    |      2 |
|  2 | dog    |      2 |
|  3 | donkey |      2 |
| 30 | cat    |      2 |
| 31 | dog    |      2 |
| 32 | donkey |      2 |
| 33 | cat    |      0 |
| 34 | dog    |      0 |
| 35 | donkey |      0 |
| 36 | cat    |      0 |
| 37 | dog    |      0 |
| 38 | donkey |      0 |
+----+--------+--------+
12 rows in set (0.00 sec)


mysql> select * from words where id > 5;

+----+--------+--------+
| id | word   | voc_id |
+----+--------+--------+
| 30 | cat    |      2 |
| 31 | dog    |      2 |
| 32 | donkey |      2 |
| 33 | cat    |      0 |
| 34 | dog    |      0 |
| 35 | donkey |      0 |
| 36 | cat    |      0 |
| 37 | dog    |      0 |
| 38 | donkey |      0 |
+----+--------+--------+
9 rows in set (0.00 sec)

mysql> select * from words where id < 5;

+----+--------+--------+
| id | word   | voc_id |
+----+--------+--------+
|  1 | cat    |      2 |
|  2 | dog    |      2 |
|  3 | donkey |      2 |
+----+--------+--------+
3 rows in set (0.00 sec)

```

Чуть больше фильтрации и перечисление полей:

```sql

mysql> select * from words where id between 30 and 34;

+----+--------+--------+
| id | word   | voc_id |
+----+--------+--------+
| 30 | cat    |      2 |
| 31 | dog    |      2 |
| 32 | donkey |      2 |
| 33 | cat    |      0 |
| 34 | dog    |      0 |
+----+--------+--------+
5 rows in set (0.01 sec)

```

### GROUP BY

Группировать можно данные, которые повторяются в группах и не будут противоречить условиям группировки. При группировке можно и логично использовать аггрегатные функции. Аггрегатные функции - особые функции SQL, которые применяются либо ко всем записям в результате выборки, либо к группам. Count - одна из таких функций. 


```sql

mysql> select voc_id from words group by voc_id;
+--------+
| voc_id |
+--------+
|      2 |
|      0 |
+--------+
2 rows in set (0.00 sec)

mysql> select voc_id, count(*) from words group by voc_id;

+--------+----------+
| voc_id | count(*) |
+--------+----------+
|      2 |        6 |
|      0 |        6 |
+--------+----------+
2 rows in set (0.00 sec)

```

### GROUP BY HAVING

Ключевое слово HAVING добавляется только после GROUP BY с целью дополнительной фильтрации результатов запроса. WHERE фильтрует их до группировки, HAVING фильтрует сгруппированные.

```sql

insert into words set word = 'test', voc_id = 2;
Query OK, 1 row affected (0.00 sec)

mysql> select voc_id, count(*) from words group by voc_id having count(*) > 6;
+--------+----------+
| voc_id | count(*) |
+--------+----------+
|      2 |        7 |
+--------+----------+

```

Используется аггрегатная функция **`count().`**

### ORDER BY

```sql

mysql> select word, voc_id from words order by word;

+--------+--------+
| word   | voc_id |
+--------+--------+
| cat    |      2 |
| cat    |      2 |
| cat    |      0 |
| cat    |      0 |
| dog    |      2 |
| dog    |      2 |
| dog    |      0 |
| dog    |      0 |
| donkey |      2 |
| donkey |      2 |
| donkey |      0 |
| donkey |      0 |
+--------+--------+
12 rows in set (0.00 sec)

mysql> select word, voc_id from words order by word, voc_id;

+--------+--------+
| word   | voc_id |
+--------+--------+
| cat    |      0 |
| cat    |      0 |
| cat    |      2 |
| cat    |      2 |
| dog    |      0 |
| dog    |      0 |
| dog    |      2 |
| dog    |      2 |
| donkey |      0 |
| donkey |      0 |
| donkey |      2 |
| donkey |      2 |
+--------+--------+
12 rows in set (0.00 sec)

mysql> select word, voc_id from words order by word, voc_id desc;

+--------+--------+
| word   | voc_id |
+--------+--------+
| cat    |      2 |
| cat    |      2 |
| cat    |      0 |
| cat    |      0 |
| dog    |      2 |
| dog    |      2 |
| dog    |      0 |
| dog    |      0 |
| donkey |      2 |
| donkey |      2 |
| donkey |      0 |
| donkey |      0 |
+--------+--------+
12 rows in set (0.00 sec)

mysql> select word, voc_id from words order by 1, 2 desc;

+--------+--------+
| word   | voc_id |
+--------+--------+
| cat    |      2 |
| cat    |      2 |
| cat    |      0 |
| cat    |      0 |
| dog    |      2 |
| dog    |      2 |
| dog    |      0 |
| dog    |      0 |
| donkey |      2 |
| donkey |      2 |
| donkey |      0 |
| donkey |      0 |
+--------+--------+
12 rows in set (0.00 sec)

```

### LIMIT и OFFSET

```sql

mysql> select word, voc_id from words order by 1, 2 desc limit 5;

+------+--------+
| word | voc_id |
+------+--------+
| cat  |      2 |
| cat  |      2 |
| cat  |      0 |
| cat  |      0 |
| dog  |      2 |
+------+--------+
5 rows in set (0.00 sec)

mysql> select word, voc_id from words order by 1, 2 desc limit 5, 2;

+------+--------+
| word | voc_id |
+------+--------+
| dog  |      2 |
| dog  |      0 |
+------+--------+
2 rows in set (0.00 sec)

```
## Полезные ссылки


[Типы данных](https://metanit.com/sql/mysql/2.3.php)

[Аггрегатные функции](https://metanit.com/sql/mysql/4.5.php)

# 3. Joins, отношения, практика запросов

## Отношения между таблицами

Как мы уже обсуждали, mySQL относится к реляционным базам данных. Реляционные БД характеризуются наличием таблиц и отношений.

Существует 3 типа отношений:

- "**Один к одному**" - когда одна запись в первой таблице соответствует одной записи во второй таблице. Встречается такая связь довольно редко. Такая связь либо избыточна, т.е. может иметь смысл просто объединить данные в одну таблицу, либо это результат модернизации архитектуры, и такое решение кем-то принято обосновано.

![](https://zametkinapolyah.ru/wp-content/uploads/2016/05/%D0%BE%D0%B4%D0%B8%D0%BD-%D0%BA%D0%BE-%D0%BE%D0%B4%D0%BD%D0%BE%D0%BC%D1%83.png)

- "**Один ко многим**" - когда одной записи в первой таблице соответствует несколько записей в другой таблице. К примеру, у клиента магазина может быть несколько номеров. Один клиент - одна запись в таблице клиента, его номера телефонов - записи в таблице телефонов. Один клиент относится ко многим номерам телефонов, но обратная связь - номер телефона к клиенту - многие к одному.

![](https://zametkinapolyah.ru/wp-content/uploads/2016/05/%D0%9E%D0%B4%D0%B8%D0%BD-%D0%BA%D0%BE-%D0%BC%D0%BD%D0%BE%D0%B3%D0%B8%D0%BC.png)

- "**Многое ко многим**" - когда одной записи в первой таблице соответствует несколько записей во второй таблице, но одной записи второй таблицы может соответствовать несколько записей первой таблицы. Классический пример - книги и авторы, ведь у автора может быть много книг, и у каждой книги может быть несколько авторов. 
Реализуется за счет создания таблицы связей, куда копируются ключи записей обеих таблиц.

![](https://zametkinapolyah.ru/wp-content/uploads/2016/05/%D0%9C%D0%BD%D0%BE%D0%B3%D0%B8%D0%B5-%D0%BA%D0%BE-%D0%BC%D0%BD%D0%BE%D0%B3%D0%B8%D0%BC.png)

## Объединения (Joins)

Запросы к одной таблице довольно редки. Чаще всего запросы к базам данных пишуться с целью получить информацию из нескольких таблиц, информация из которых объединяется по определенным условиям.

Создадим таблицы авторов, книг, жанров и таблицу связей для авторов и книг (многие ко многим):

```sql
CREATE TABLE authors (
	id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
	name VARCHAR(100) NOT NULL DEFAULT 'people',
	year DATE NOT NULL DEFAULT '1970-01-01'
);

CREATE TABLE books (
	id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
	title VARCHAR(100) NOT NULL DEFAULT 'noname',
	genre_id INT NOT NULL DEFAULT '0'
);

CREATE TABLE genres (
	id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
	genre VARCHAR(100) NOT NULL DEFAULT 'unknown'
);

CREATE TABLE authors_books (
	author_id INT NOT NULL DEFAULT 0,
	book_id INT NOT NULL DEFAULT 0
);
```

Далее следует заполнить таблицу данными:

```sql
INSERT INTO genres (genre) VALUES
	('SF'),
	('novel'),
	('story'),
	('horror');

INSERT INTO books(title, genre_id) VALUES
	("Мастер и Маргарита", 2),
	("Фауст", 0),
	("Белый клык", 3),
	("Дюна", 1),
	("Война и мир", 2);

INSERT INTO authors (name) VALUES
	('Френк Герберт'),
	('Михаил Булгаков'), 
	('Ждек Лондон'), 
	('Иоган Гёте'), 
	('Роберт Хайнлайн');

INSERT INTO authors_books (author_id, book_id) VALUES 
	(1, 4),
	(2, 1),
	(3, 3),
	(4, 2);
```


![](http://homes.ieu.edu.tr/culudagli/files/CE223/MySQL/mysql-jointypes-1.png)




Данные готовы, теперь можно изучать объединения таблиц. Начнем мы с объединения двух таблиц в одном запросе:

```sql
SELECT
	title,
	genre 
FROM 
	books
	INNER JOIN genres ON (books.genre_id = genre.id);
```

```
+------------------------------------+-------+
| title                              | genre |
+------------------------------------+-------+
| Мастер и Маргарита                 | novel |
| Белый клык                         | story |
| Дюна                               | SF    |
| Война и мир                        | novel |
+------------------------------------+-------+
```

**`INNER JOIN`** выводит записи из левой таблицы (первой из двух таблиц, которые он объединяет), для которых найдется соответствующая запись в правой (второй и последней в списке) таблице. Если соответствия в правой таблице нет, такая запись не выводится. В данном случае можно видеть, что запись о книге "Фауст" не выводится. Это происходит из-за того, что `genre_id` у этой записи равен нулю, а такого жанра в таблице жанров нет.
Так же в результат не попадает жанр horror, так как нет ни единой книги с таким жанром.

```sql
SELECT
	title,
	genre 
FROM 
	books
	LEFT JOIN genres ON (books.genre_id = genre.id);
```
```
+------------------------------------+-------+
| title                              | genre |
+------------------------------------+-------+
| Мастер и Маргарита                 | novel |
| Фауст                              | NULL  |
| Белый клык                         | story |
| Дюна                               | SF    |
| War and Peace                      | novel |
+------------------------------------+-------+
```
**`LEFT JOIN`** выводит **ВСЕ** записи из левой таблицы. Для тех записей, которым находится соответствие в правой, он, аналогично **`INNER JOIN`**-у, выведет соответствующие данные из второй таблицы. Для тех же, которым соответствия не нашлось, он выведет в столбцах правой таблицы **`NULL`**.

**`RIGHT JOIN`** поступает аналогичным образом с правой таблицей: выводит все записи из нее, добавляя записи из левой. Где соответствия не находится, добавляет в столбцах левой таблицы **`NULL`**.

```sql
SELECT
	title,
	genre 
FROM 
	books
	RIGHT JOIN genres ON (books.genre_id = genre.id);
```

```
+------------------------------------+--------+
| title                              | genre  |
+------------------------------------+--------+
| Мастер и Маргарита                 | novel  |
| Белый клык                         | story  |
| Дюна                               | SF     |
| War and Peace                      | novel  |
| NULL                               | horror |
+------------------------------------+--------+
```


Если у вас возникнет необходимость увидеть все книги и все жанры вне зависимости от наличия соответствующих записей в другой таблице, но где связи есть - связать таблицы, можно объединить результаты двух запросов:


```sql
SELECT
	title,
	genre 
FROM 
	books
	LEFT JOIN genres ON (books.genre_id = genre.id)

UNION

SELECT
	title,
	genre 
FROM 
	books
	RIGHT JOIN genres ON (books.genre_id = genre.id);
```


```
+------------------------------------+--------+
| title                              | genre  |
+------------------------------------+--------+
| Мастер и Маргарита                 | novel  |
| Фауст                              | NULL   |
| Белый клык                         | story  |
| Дюна                               | SF     |
| War and Peace                      | novel  |
| NULL                               | horror |
+------------------------------------+--------+
```

Классический вопрос, как посмотреть книги, у которых нет жанра, решается просто:

```sql
SELECT
	title,
	genre 
FROM 
	books
	LEFT JOIN genres ON (books.genre_id = genre.id)
WHERE
	genre IS NULL;
```
```
+------------+-------+
| title      | genre |
+------------+-------+
| Фауст      | NULL  |
+------------+-------+
```
Если поля для связи называются одинаково, например, поле id в таблице genres называется genre_id, запрос можно немного упростить. Для демонстрации переименуем поле и выполним этот запрос:

```sql

ALTER TABLE 
	genres 
CHANGE 
	id genre_id INT NOT NULL;

SELECT
	title,
	genre 
FROM 
	books
	LEFT JOIN genres USING(genre_id);
```

Результат будет тот же, что и у обычного **`LEFT JOIN`** запроса, но сам запрос короче.

## Практика

- Объединить авторов с книгами посредством таблицы связей
- Построить фамильное древо по мужской линии


[Статья о joins](https://anton-pribora.ru/articles/mysql/mysql-join/)

# 4. Индексы, хранимые процедуры, триггеры, нормализвция и прочая теория.

## Производительность, bottleneck, slow log, select explain


### Производительность и bottleneck
Если у сайта или приложения есть бэкенд с базой данных, и это приложение или этот сайт работает медленнее ожидаемого, тормозит - очень высока вероятность, что причиной тому низкая скорость работы базы данных. Для самого узкого места по производительности есть специальный термин - **bottleneck, бутылочное горлышко**. Так вот, бутылочным горлышком производительности любого сайта часто является производительность базы данных.

![REAL DB](realdb.jpg)

Производительность базы данных чаще всего падает в двух случаях:

- чересчур много запросов
- очень медленно работающие запросы

Первый случай решается пересмотром кода проекта в целом. Лишние запросы можно убрать, объединить с нелишними и оптимизировать таким образом количество обращений к БД.

Второй случай специфичнее, здесь нужно обнаружить медленные запросы и ускорить их. К слову, медленные запросы, как правило,- это запросы `select`.

### slow log, my.cnf, my.ini

Для автоматического логирования медленных запросов используется **slow log**, включить который можно в конфигурационном файле **my.cnf** или **my.ini** (ini для Windows, cnf для Linux)

Для Open Server файл лежит в **userdata\config**

Файл конфигурации **my.cnf/my.ini** очень интересный, рекомендую познакомиться желающим. В интернете масса примеров с разъяснениями смысла каждой строки.
[my.cnf](https://ruhighload.com/my.cnf)

Включить slow log помогут инструкции
`slow_query_log`, значением которой должен быть путь (обычно закомментирована, можно просто включить) и `long_query_time`, значение которой - количество секунд, свыше которых запрос считается медленным.

![my.cnf](my.cnf.png)

После сохранения файла перезагрузите MySQL.

### Ускорение запросов, select explain

После того, как вы обнаружите медженный запрос, потребуется его ускорить. Для этого необходимо понять, что в нем такого ммедленного и неверного. Для этого выполните тот же запрос `select` с указанием ключевого слова `explain`.

Вот [тут](https://www.sitepoint.com/using-explain-to-write-better-mysql-queries/) можно почитать подробно о каждом столбце в результате `select explain`

Слежует обратить внимание на наличие или отсутствие ключей или индексов в поле **`key`** и количество просмотренных записей в поле **`rows`**. Отсутствие ключа и большое количество записей, вкупе с длительным сроком выполнения запроса говорит о том, что запрос надо оптимизировать.

## Индексы

Просмотреть все индексы, существующие в таблице, можно при помощи запроса `SHOW INDEX FROM ` с добавлением имени таблицы:

```sql
SHOW INDEX FROM film;

+-------+------------+-----------------------------+--------------+----------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table | Non_unique | Key_name                    | Seq_in_index | Column_name          | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+-------+------------+-----------------------------+--------------+----------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| film  |          0 | PRIMARY                     |            1 | film_id              | A         |        1000 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| film  |          1 | idx_title                   |            1 | title                | A         |        1000 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| film  |          1 | idx_fk_language_id          |            1 | language_id          | A         |           1 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| film  |          1 | idx_fk_original_language_id |            1 | original_language_id | A         |           1 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
+-------+------------+-----------------------------+--------------+----------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
4 rows in set (0.00 sec)
```
Добавляются индексы как при создании таблицы, так и при последующей ее модификации:

```sql
mysql> alter table film add key rrate (rental_rate);
Query OK, 0 rows affected (0.07 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

Индексы сильно ускоряют поиск по полю или группе полей, которые индексируют, но замедляют процесс добавления новых данных, редактирования их и удления строк, поскольку перестраивает дерево поиска записей.

![](B-Tree-Deletions.gif)

## Нормализация

**Нормализацией** называется процесс приведения таблицы или всех БД к определенному виду, содержащему меньше потенциальных проблем и аномалий, чем существующий вид.

**Нормальными формами** называется ряд форм, к которым можно проводить таблицы в процессе нормализации. Каждая форма требует от таблицы соблюдения определенных правил.

Автором первых трех нормальных форм, с которыми нам предстоит сегодня познакомится, является Эдгар Кодд.

![Эдгар Кодд](Codd.jpg)

Приступим.

Многие данные изначально неверно размещаны в таблицах, и это может привести к лишним проблемам. К примеру, вот эти данные содержат ряд проблем. Внесем их для начала.

Создаем таблицу:

```sql
CREATE TABLE cars(
  brend VARCHAR(100) NOT NULL DEFAULT "",
  model VARCHAR(100) NOT NULL DEFAULT ""
);
```

Внесем данные в таблицу:

```sql
INSERT INTO cars
  (model, brend)
VALUES
  ('z4, x5, x6', 'BMW'),
  ('E200, 600 Pullman, W140', 'Mercedes'),
  ('Golf, Jetta, Passat', 'Wolksvagen');
```

Просмотрим результат, выведем данные из таблицы:

```sql
SELECT * FROM cars;

+------------+-------------------------+
| brend      | model                   |
+------------+-------------------------+
| BMW        | z4, x5, x6              |
| Mercedes   | E200, 600 Pullman, W140 |
| Wolksvagen | Golf, Jetta, Passat     |
+------------+-------------------------+

3 rows in set (0.00 sec)
```

Вроде бы нигде никаких сложностей нет, но если потребуется найти конкретную модель, сложности появятся.
Исправить проблемы этой таблицы нам поможет **первая нормальная форма**.

**Первая нормальная форма** требует соблюдения следующих правил:

- Строки в таблице уникальны, их порядок не играет роли, они независимы друг от друга.
- Столбцы в таблице уникальны, их порядок не играет роли
- Данные в столбце атомарны, т.е. неделимы (неделимость вариативна в зависимости от точки зрения)

**Практическое задание:** Приведите таблицу cars к первой нормальной форме.


## Практика

- Объединить авторов с книгами посредством таблицы связей
- Построить фамильное древо по мужской линии

## Полезные ссылки

[Отличная статья об индексах](https://ruhighload.com/%D0%98%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D1%8B+%D0%B2+mysql)

[Нормализация](https://office-menu.ru/uroki-sql/51-normalizatsiya-bazy-dannykh)

[Еще нормализация](https://habr.com/ru/post/254773/)

[И снова нормализация](https://oracle-patches.com/db/3632-%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%B8-%D0%B4%D0%B5%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%B1%D0%B0%D0%B7%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%84%D0%BE%D1%80%D0%BC%D1%8B)

[Статья об explain](https://ruhighload.com/explain+%d0%b2+mysql)

[B-деревья](https://neerc.ifmo.ru/wiki/index.php?title=B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE)

**Следующий урок - модуль, повторять всё!**



